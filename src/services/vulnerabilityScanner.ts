import { AdminSyncService } from './adminSyncService';

export interface Vulnerability {
  id: string;
  type: 'xss' | 'injection' | 'secrets';
  severity: 'critique' | 'eleve' | 'moyen' | 'faible';
  line: number;
  description: string;
  codeSnippet: string;
  fix: string;
  explanation: string;
}

export interface VulnerabilityPattern {
  patterns: RegExp[];
  severity: 'critique' | 'eleve' | 'moyen' | 'faible';
  description: string;
  fix: string;
  explanation: string;
}

// Patterns par défaut (seront remplacés par les règles de la base de données)
const defaultVulnerabilityPatterns: Record<string, VulnerabilityPattern> = {
  xss: {
    patterns: [
      /innerHTML\s*=\s*.*(?:req\.|request\.|input|user|params|query|body)/gi,
      /outerHTML\s*=\s*.*(?:req\.|request\.|input|user|params|query|body)/gi,
      /insertAdjacentHTML\s*\([^)]*(?:req\.|request\.|input|user|params|query|body)/gi,
      /document\.write\s*\([^)]*(?:req\.|request\.|input|user|params|query|body)/gi,
      /\.html\(\s*(?:req\.|request\.|input|user|params|query|body)/gi
    ],
    severity: 'eleve',
    description: 'Vulnérabilité XSS - Injection de contenu HTML non sécurisé',
    fix: 'Utilisez textContent au lieu de innerHTML, ou échappez le contenu HTML',
    explanation: 'Les attaques XSS permettent aux attaquants d\'exécuter du JavaScript malveillant dans le navigateur des utilisateurs.'
  },
  injection: {
    patterns: [
      /eval\s*\(/gi,
      /new\s+Function\s*\(/gi,
      /setTimeout\s*\(\s*["'][^"']*\+/gi,
      /setInterval\s*\(\s*["'][^"']*\+/gi,
      /exec\s*\(/gi
    ],
    severity: 'critique',
    description: 'Vulnérabilité d\'injection de code - Exécution de code non sécurisé',
    fix: 'Évitez eval(), utilisez JSON.parse() pour les données JSON, ou des alternatives sécurisées',
    explanation: 'L\'injection de code permet aux attaquants d\'exécuter du code arbitraire sur votre système.'
  },
  secrets: {
    patterns: [
      /password\s*[=:]\s*["'][^"']{3,}["']/gi,
      /api[_-]?key\s*[=:]\s*["'][^"']{10,}["']/gi,
      /secret\s*[=:]\s*["'][^"']{6,}["']/gi,
      /token\s*[=:]\s*["'][^"']{10,}["']/gi,
      /private[_-]?key\s*[=:]\s*["'][^"']{20,}["']/gi,
      /database[_-]?url\s*[=:]\s*["'][^"']{10,}["']/gi
    ],
    severity: 'eleve',
    description: 'Secrets codés en dur - Informations sensibles exposées dans le code',
    fix: 'Utilisez des variables d\'environnement ou un gestionnaire de secrets',
    explanation: 'Les secrets codés en dur peuvent être découverts par les attaquants et compromettre votre système.'
  }
};

// Fonction pour convertir les règles de sécurité de la base de données en patterns
async function getSecurityRulesPatterns(): Promise<Record<string, VulnerabilityPattern>> {
  try {
    const securityRules = await AdminSyncService.getAllSecurityRules();
    
    if (!securityRules || securityRules.length === 0) {
      console.log('⚠️ Aucune règle de sécurité trouvée, utilisation des patterns par défaut');
      return defaultVulnerabilityPatterns;
    }
    
    const patterns: Record<string, VulnerabilityPattern> = {};
    
    // Regrouper les règles par catégorie
    securityRules.forEach(rule => {
      if (!rule.isActive) return;
      
      // Normaliser la catégorie pour correspondre aux types attendus
      let type = rule.category.toLowerCase();
      
      // S'assurer que le type est l'un des types valides
      if (type !== 'xss' && type !== 'injection' && type !== 'secrets') {
        if (type.includes('xss')) type = 'xss';
        else if (type.includes('inject')) type = 'injection';
        else if (type.includes('secret') || type.includes('password') || type.includes('key')) type = 'secrets';
        else type = 'xss'; // Type par défaut
      }
      
      const severity = mapSeverity(rule.severity);
      
      if (!patterns[type]) {
        patterns[type] = {
          patterns: [],
          severity,
          description: rule.description || `Vulnérabilité de type ${type}`,
          fix: rule.fixSuggestion || `Corrigez cette vulnérabilité de ${type}`,
          explanation: rule.description || `Cette vulnérabilité peut compromettre la sécurité de votre application.`
        };
      }
      
      try {
        // Convertir le pattern en RegExp
        const regexPattern = new RegExp(rule.pattern, 'gi');
        patterns[type].patterns.push(regexPattern);
      } catch (error) {
        console.error(`❌ Erreur lors de la conversion du pattern ${rule.pattern} en RegExp:`, error);
      }
    });
    
    // Si aucune catégorie n'a été trouvée, utiliser les patterns par défaut
    if (Object.keys(patterns).length === 0) {
      return defaultVulnerabilityPatterns;
    }
    
    return patterns;
  } catch (error) {
    console.error('❌ Erreur lors de la récupération des règles de sécurité:', error);
    return defaultVulnerabilityPatterns;
  }
}

// Mapper les sévérités de la base de données vers le format de l'application
function mapSeverity(severity: string): 'critique' | 'eleve' | 'moyen' | 'faible' {
  switch (severity) {
    case 'critical': return 'critique';
    case 'high': return 'eleve';
    case 'medium': return 'moyen';
    case 'low': return 'faible';
    default: return 'moyen';
  }
}

export async function scanCode(code: string, filename: string = 'code.js'): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];
  const lines = code.split('\n');
  
  // Récupérer les patterns de vulnérabilités depuis la base de données
  const vulnerabilityPatterns = await getSecurityRulesPatterns();

  Object.entries(vulnerabilityPatterns).forEach(([type, config]) => {
    config.patterns.forEach(pattern => {
      let match;
      // Réinitialiser le lastIndex pour éviter les problèmes avec les expressions régulières globales
      pattern.lastIndex = 0;
      
      while ((match = pattern.exec(code)) !== null) {
        const lineNumber = code.substring(0, match.index).split('\n').length;
        const lineContent = lines[lineNumber - 1]?.trim() || '';
        
        // Éviter les doublons sur la même ligne
        const existingVuln = vulnerabilities.find(v => 
          v.type === type && v.line === lineNumber
        );
        
        if (!existingVuln && lineContent) {
          vulnerabilities.push({
            id: `${type}-${lineNumber}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            type: type as 'xss' | 'injection' | 'secrets',
            severity: config.severity,
            line: lineNumber,
            description: config.description,
            codeSnippet: lineContent,
            fix: config.fix,
            explanation: config.explanation
          });
        }
      }
    });
  });

  return vulnerabilities.sort((a, b) => {
    const severityOrder = { critique: 0, eleve: 1, moyen: 2, faible: 3 };
    return severityOrder[a.severity] - severityOrder[b.severity];
  });
}

export const exampleVulnerableCode = `// Exemple de code avec vulnérabilités pour test
function handleUserInput() {
  const userInput = req.body.content;
  
  // Vulnérabilité XSS
  document.getElementById('output').innerHTML = userInput;
  
  // Vulnérabilité d'injection
  eval('console.log("' + userInput + '")');
  
  // Secret codé en dur
  const apiKey = "sk-1234567890abcdef";
  const password = "supersecret123";
  
  // Code sécurisé (exemple)
  document.getElementById('safe-output').textContent = userInput;
  
  // Autre vulnérabilité XSS
  element.outerHTML = req.query.html;
  
  // Injection via Function
  new Function('return ' + userInput)();
}

// Configuration de base de données non sécurisée
const dbConfig = {
  host: 'localhost',
  user: 'admin',
  password: 'admin123',
  database: 'myapp'
};`;